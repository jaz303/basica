/* Helpers */

{
	function makeGoto(line) {
		return { type: "command", name: "GOTO", args: [line] };
	}
}

_
    = [ \t]*

__
	= [ \t]+

non_zero_digit
    = [1-9]

digit
    = [0-9]

float
    = $ ( non_zero_digit digit* '.' digit+ )

integer
    = $ ( digit+ )

function_name
	= $( [a-zA-Z] [a-zA-Z0-9]* '$'? )

TERM
	= _ "\n"

/* Productions */

Line
	= _ x:NumberedLine TERM { return x; }
	/ _ x:Statements TERM { return x; }

NumberedLine
	= line:integer _ stmts:Statements {
		return {
			line: parseInt(line, 10),
			statements: stmts.statements
		};
	}

Statements
	= head:Statement tail:(':' _ Statement)* {
		return {
			line: null,
			statements: [head].concat(tail.map(function(t) { return t[2]; }))
		};
	}

Statement
	= IfStatement
	/ AssignStatement
	/ CommandStatement

IfStatement
	= [iI][fF] __ exp:Expression __ b:ConsequentPart e:ElsePart? {
		return { 
			type: "if",
			condition: exp,
			bodyPart: b,
			elsePart: e || null
		};
	}

ConsequentPart
	= [tT][hH][eE][nN] __ line:Integer _ { return makeGoto(line); }
	/ [gG][oO][tT][oO] __ line:Integer _ { return makeGoto(line); }
	/ [tT][hH][eE][nN] __ stmt:Statement { return stmt; }

ElsePart
	= [eE][lL][sS][eE] __ line:Integer _ { return makeGoto(line); }
	/ [eE][lL][sS][eE] __ stmt:Statement { return stmt; }

AssignStatement
	= left:Ident _ '=' _ right:Expression _ {
		return { type: "assign", left: left, right: right };
	}

CommandStatement
	= name:CommandName _ args:ArgList? {
		return { type: "command", name: name, args: args || [] };
	}

VariableName
	= name:$( [a-zA-Z] [a-zA-Z0-9]* [$%]? ) {
		return name.toUpperCase();
	}

CommandName
	= name:$( [a-zA-Z] [a-zA-Z0-9]* ) {
		return name.toUpperCase();
	}

ArgList
	= head:Expression _ tail:(',' _ Expression _)* {
		return [head].concat(tail.map(function(t) { return t[2]; }));
	}

Expression
	= AdditiveExpression

AdditiveExpression
	= head:IntegerDivisionExpression tail:([-+] _ IntegerDivisionExpression)* {
		return head;
	}

IntegerDivisionExpression
	= head:MultiplicativeExpression tail:("\\" _ MultiplicativeExpression)* {
		return head;
	}

MultiplicativeExpression
	= head:UnaryExpression tail:([*/] _ UnaryExpression)* {
		return head;
	}

UnaryExpression
	= [nN][oO][tT] __ exp:UnaryExpression {
		return { type: "not", exp: exp };
	}
	/ '-' _ exp:UnaryExpression {
		return { type: "negate", exp: exp };
	}
	/ v:FunctionCall _ { return v; }

FunctionCall
	= name:function_name '(' _ args:ArgList ')' _ {
		return {
			type: "function-call",
			name: name.toUpperCase(),
			args: args
		};
	}
	/ Atom

Atom
	= Float
	/ Integer
	/ String
	/ Ident
	/ '(' _ exp:Expression _ ')' _ { return exp; }

Float
	= val:float { return parseFloat(val); }

Integer
	= val:integer { return parseInt(val, 10); }

String
	= '"' str:$( StringChar* ) '"' { return str; }

StringChar
	= '\\n' { return "\n"; }
	/ '\\t' { return "\t"; }
	/ '\\"' { return '"'; }
	/ '\\\\' { return "\\"; }
	/ [^\"]

Ident
	= name:VariableName {
		return { "type": "ident", name: name }
	}
